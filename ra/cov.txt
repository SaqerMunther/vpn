package com.app.dev.cmon.cache;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Cache {
    private static Cache instance = new Cache();
    private Map<String, Object> cache = new ConcurrentHashMap<>();

    private Cache() { }

    public static Cache getInstance() {
        return instance;
    }

    public <T> T getCachedObject(String key) {
        return (T) cache.get(key);
    }

    public void putCachedObject(String key, Object value) {
        cache.put(key, value);
    }
}


package com.app.dev.cmon.cache;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.Element;
import net.sf.ehcache.config.CacheConfiguration;
import net.sf.ehcache.config.Configuration;
import net.sf.ehcache.store.MemoryStoreEvictionPolicy;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.stream.Collectors;

import com.app.dev.cmon.components.ViewInfo;
import com.app.dev.cmon.components.Views;
import com.app.dev.cmon.controllers.DataAccess;
import com.app.dev.cmon.utilites.CacheConstants;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CacheService {
    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);
    private static CacheService instance;
    
    private CacheManager cacheManager;
    private Cache dataCache;
    private Timer timer;
    private DataAccess da = new DataAccess();
    
    private Map<Integer, String> viewNameMap;
    private Map<Integer, List<String>> viewCountryMap;
    
    private final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    
    // Private constructor for Singleton
    private CacheService() {
        Configuration config = new Configuration();
        // Set maximum entries to 1500 as required
        CacheConfiguration cacheConfig = new CacheConfiguration("dataCache", 1500)
                .eternal(false)
                .timeToIdleSeconds(180)
                .timeToLiveSeconds(300)
                .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LRU);
        config.addCache(cacheConfig);
        cacheManager = CacheManager.newInstance(config);
        dataCache = cacheManager.getCache("dataCache");
        scheduleCacheRefresh();
        logger.info("CacheService initialized and cache refresh scheduled.");
    }

    public static synchronized CacheService getInstance() {
        if (instance == null) {
            instance = new CacheService();
        }
        return instance;
    }

    private void scheduleCacheRefresh() {
        timer = new Timer();
        // Schedule cache refresh every 10 minutes with an initial delay of 5 seconds.
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                String date = sdf.format(new Date());
                refreshDataPerWeekCache(date);
            }
        }, 5000, 10 * 60 * 1000);
        logger.info("Cache refresh task scheduled to run every 10 minutes after an initial delay of 5 seconds.");
    }

    // Helper method to generate a cache key consistently
    private String generateCacheKey(String type, String isNew, int viewId, String country, String date) {
        return type.toLowerCase() + "_" + isNew.toLowerCase() + "_" + viewId + "_" + country.toLowerCase() + "_" + date;
    }
    
    // Refresh the entire cache (for all views) using the instance maps
    public void refreshDataPerWeekCache(String date) {
        logger.info("Refreshing dataCache...");
        dataCache.removeAll();
        logger.info("dataCache has been cleared.");
        
        for (String type : CacheConstants.RADAR_TYPES) {
            for (String isNew : CacheConstants.RADAR_IS_NEW) {
                for (Map.Entry<Integer, List<String>> entry : viewCountryMap.entrySet()) {
                    Integer viewId = entry.getKey();
                    List<String> countries = entry.getValue();
                    for (String country : countries) {
                        List<Integer> subViews = da.getSubViews(viewId)
                                .stream()
                                .map(Views::getId)
                                .collect(Collectors.toList());
                        for (Integer subViewId : subViews) {
                            String cacheKey = generateCacheKey(type, isNew, viewId, country, date);
                            logger.debug("Populating cache for key: {}", cacheKey);
                            List<ViewInfo> data = da.getCoveragePerWeek(viewId, subViewId,
                                    country.equalsIgnoreCase("all") ? "" : country,
                                    type, viewNameMap.get(viewId), date);
                            dataCache.put(new Element(cacheKey, data));
                            logger.info("Data for key: {} has been cached.", cacheKey);
                        }
                    }
                }
            }
        }
        logger.info("Current cache size after refresh: {}", dataCache.getSize());
    }
    
    // Preload cache in background without blocking the initial view load
    public void preloadCacheBackground(String date) {
        new Thread(() -> {
            logger.info("Starting background cache preloading.");
            refreshDataPerWeekCache(date);
            logger.info("Background cache preloading completed.");
        }).start();
    }

    // Retrieve data from cache or fetch and cache it if missing
    public List<ViewInfo> getDataPerWeek(String type, String isNew, int viewId, int subViewId, String country, String viewText, String date) {
        String cacheKey = generateCacheKey(type, isNew, viewId, country, date);
        logger.debug("Fetching data for cache key: {}", cacheKey);
        
        Element cachedElement = dataCache.get(cacheKey);
        if (cachedElement != null) {
            logger.info("Cache hit for key: {}", cacheKey);
            return (List<ViewInfo>) cachedElement.getObjectValue();
        }
        
        logger.info("Cache miss for key: {}. Fetching data from DataAccess.", cacheKey);
        List<ViewInfo> data = da.getCoveragePerWeek(viewId, subViewId,
                country.equalsIgnoreCase("all") ? "" : country,
                type, viewText, date);
        dataCache.put(new Element(cacheKey, data));
        logger.info("Data for key: {} has been cached.", cacheKey);
        logger.info("Current cache size: {}", dataCache.getSize());
        
        return data;
    }
    
    public void shutdown() {
        if (timer != null) {
            timer.cancel();
            logger.info("Cache refresh timer cancelled.");
        }
        cacheManager.shutdown();
        logger.info("CacheManager has been shut down.");
    }

    // Getters and Setters for viewCountryMap and viewNameMap
    public Map<Integer, List<String>> getViewCountryMap() {
        return viewCountryMap;
    }

    public void setViewCountryMap(Map<Integer, List<String>> viewCountryMap) {
        this.viewCountryMap = viewCountryMap;
    }

    public Map<Integer, String> getViewNameMap() {
        return viewNameMap;
    }

    public void setViewNameMap(Map<Integer, String> viewNameMap) {
        this.viewNameMap = viewNameMap;
    }
}


package com.app.dev.cmon.cache;

import com.arabbank.dev.utility.Pair;
import java.util.Map;

public class CoverageMaps {
    private Map<String, Pair<Integer, Integer>> oneMonthMap;
    private Map<String, Pair<Integer, Integer>> twoMonthMap;

    public CoverageMaps(Map<String, Pair<Integer, Integer>> oneMonthMap, Map<String, Pair<Integer, Integer>> twoMonthMap) {
        this.oneMonthMap = oneMonthMap;
        this.twoMonthMap = twoMonthMap;
    }

    public Map<String, Pair<Integer, Integer>> getOneMonthMap() {
        return oneMonthMap;
    }

    public Map<String, Pair<Integer, Integer>> getTwoMonthMap() {
        return twoMonthMap;
    }
}



i want to cache also 

		public List<ViewInfo> getCompCircleScore(String type) {
			if (circleExiCompDetails == null || circleExiCompDetails.size() < 1) {
				circleExiCompDetails = da.getComplyCirclePerScore(viewId, subViewId,
						country.equalsIgnoreCase("all") ? "" : country, type, viewText,
						sdf.format(radar.getDate1()).trim());
			}
			return circleExiCompDetails;

		} 



	private void processAndMapData() {
	    List<AssetInfo> listOne = da.getAllCoverage(viewId, -1, "", sdf.format(getPreviousMonth(1)));
	    List<AssetInfo> listTwo = da.getAllCoverage(viewId, -1, "", sdf.format(getPreviousMonth(2)));
	    
	    oneMonthMap = processAssetList(listOne);

	    twoMonthMap = processAssetList(listTwo);
	    coverageAll = da.getAllCoverage(viewId, subViewId, country ,sdf.format(radar.getDate1()).trim());
	}
