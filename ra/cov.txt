// --- Assumed utility methods for date and country normalization ---

/**
 * Returns the normalized country string: if null or "all", returns "ALL".
 */
private String normalizeCountry(String country) {
    return (country == null || country.equalsIgnoreCase("all")) ? "ALL" : country;
}

/**
 * Returns the formatted date string for the current radar date.
 */
private String getCurrentRadarDateStr() {
    return sdf.format(radar.getDate1()).trim();
}

// --- Updated method for processing and mapping data ---

/**
 * Processes asset data for the given view, sub-view, and country, then caches the resulting maps.
 * The maps (oneMonthMap and twoMonthMap) are keyed under a unique cache key.
 */
private void processAndMapData(int viewId, int subViewId, String country) {
    String normalizedCountry = normalizeCountry(country);
    String cacheKey = "processAndMapData_" + viewId + "_" + subViewId + "_" + normalizedCountry;
    
    // Try to retrieve cached maps (assume the cache holds a Map with two entries)
    Map<String, Map<String, Pair<Integer, Integer>>> cachedResult = 
            CacheService.getInstance().<Map<String, Map<String, Pair<Integer, Integer>>>>getCachedObject(cacheKey);
    
    if (cachedResult != null) {
        oneMonthMap = cachedResult.get("oneMonthMap");
        twoMonthMap = cachedResult.get("twoMonthMap");
        return;
    }
    
    // Otherwise, fetch the data from the data access object.
    String dateOne = sdf.format(getPreviousMonth(1));
    String dateTwo = sdf.format(getPreviousMonth(2));
    
    List<AssetInfo> listOne = da.getAllCoverage(viewId, subViewId, country, dateOne);
    List<AssetInfo> listTwo = da.getAllCoverage(viewId, subViewId, country, dateTwo);
    
    Map<String, Pair<Integer, Integer>> oneMonth = processAssetList(listOne);
    Map<String, Pair<Integer, Integer>> twoMonth = processAssetList(listTwo);
    
    // Prepare result map and cache it.
    Map<String, Map<String, Pair<Integer, Integer>>> result = new HashMap<>();
    result.put("oneMonthMap", oneMonth);
    result.put("twoMonthMap", twoMonth);
    
    CacheService.getInstance().putCachedObject(cacheKey, result);
    
    // Also update the local instance variables.
    oneMonthMap = oneMonth;
    twoMonthMap = twoMonth;
}

// --- Updated method for retrieving compliance circle scores ---

/**
 * Returns the circle score for compliance. If the data is cached, returns it; otherwise, fetches and caches it.
 */
public List<ViewInfo> getCompCircleScore(String type) {
    String normalizedCountry = normalizeCountry(country);
    String dateStr = getCurrentRadarDateStr();
    String cacheKey = "compCircleScore_" + viewId + "_" + subViewId + "_" + normalizedCountry + "_" + type + "_" + dateStr;
    
    List<ViewInfo> cachedScore = CacheService.getInstance().<List<ViewInfo>>getCachedObject(cacheKey);
    if (cachedScore != null && !cachedScore.isEmpty()) {
        return cachedScore;
    }
    
    List<ViewInfo> result = da.getComplyCirclePerScore(
            viewId, subViewId,
            country.equalsIgnoreCase("all") ? "" : country,
            type,
            viewText,
            dateStr);
    
    CacheService.getInstance().putCachedObject(cacheKey, result);
    return result;
}

// --- Methods to preload caches in background ---

/**
 * Iterates over all available countries and sub-views for the current viewId to pre-cache the
 * processAndMapData results.
 */
public void preloadProcessAndMapDataCache() {
    List<String> countries = radar.getCountryMap().get(viewId);
    if (countries == null || countries.isEmpty()) {
        countries = Collections.singletonList("ALL");
    }
    // Get subviews for the current view (if none, use -1 as default)
    List<Views> subViews = radar.getSubViews(viewId);
    if (subViews == null || subViews.isEmpty()) {
        for (String c : countries) {
            processAndMapData(viewId, -1, c);
        }
    } else {
        for (Views sub : subViews) {
            for (String c : countries) {
                processAndMapData(viewId, sub.getId(), c);
            }
        }
    }
}

/**
 * Iterates over all available countries and sub-views (and for each type if needed)
 * to preload the compliance circle score cache.
 */
public void preloadCompCircleScoreCache() {
    // Define the types you wish to preload; here we use "Comp" as an example.
    List<String> types = Arrays.asList("Comp");
    List<String> countries = radar.getCountryMap().get(viewId);
    if (countries == null || countries.isEmpty()) {
        countries = Collections.singletonList("ALL");
    }
    String dateStr = getCurrentRadarDateStr();
    List<Views> subViews = radar.getSubViews(viewId);
    
    if (subViews == null || subViews.isEmpty()) {
        for (String c : countries) {
            for (String t : types) {
                String normalizedCountry = normalizeCountry(c);
                String cacheKey = "compCircleScore_" + viewId + "_" + (-1) + "_" + normalizedCountry + "_" + t + "_" + dateStr;
                List<ViewInfo> result = da.getComplyCirclePerScore(
                        viewId, -1,
                        c.equalsIgnoreCase("all") ? "" : c,
                        t, viewText, dateStr);
                CacheService.getInstance().putCachedObject(cacheKey, result);
            }
        }
    } else {
        for (Views sub : subViews) {
            for (String c : countries) {
                for (String t : types) {
                    String normalizedCountry = normalizeCountry(c);
                    String cacheKey = "compCircleScore_" + viewId + "_" + sub.getId() + "_" + normalizedCountry + "_" + t + "_" + dateStr;
                    List<ViewInfo> result = da.getComplyCirclePerScore(
                            viewId, sub.getId(),
                            c.equalsIgnoreCase("all") ? "" : c,
                            t, viewText, dateStr);
                    CacheService.getInstance().putCachedObject(cacheKey, result);
                }
            }
        }
    }
}

// --- In your @PostConstruct initialization method ---

@PostConstruct
public void init() {
    // ... existing initialization logic ...
    
    // For example, after setting viewId, country, and subViewId from the radar controller:
    viewId = radar.getViewId();
    subViewId = radar.getSubViewId();
    country = radar.getCountry();
    viewText = radar.getViewText();
    
    // Optionally, call processAndMapData for the current selection synchronously:
    processAndMapData(viewId, subViewId, country);
    
    // Then launch background threads to preload caches for all combinations.
    new Thread(() -> {
         preloadProcessAndMapDataCache();
         preloadCompCircleScoreCache();
    }).start();
}
