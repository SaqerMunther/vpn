package com.app.dev.cmon.cache;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.Element;
import net.sf.ehcache.config.CacheConfiguration;
import net.sf.ehcache.config.Configuration;
import net.sf.ehcache.store.MemoryStoreEvictionPolicy;

import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.stream.Collectors;

import com.app.dev.cmon.components.AssetInfo;
import com.app.dev.cmon.components.ViewInfo;
import com.app.dev.cmon.components.Views;
import com.app.dev.cmon.controllers.DataAccess;
import com.app.dev.cmon.utilites.CacheConstants;
import com.arabbank.dev.utility.Pair;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CacheService {
    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);
    private static CacheService instance;
    
    private CacheManager cacheManager;
    private Cache dataCache;
    private Timer timer;
    private DataAccess da = new DataAccess();
    
    private Map<Integer, String> viewNameMap;
    private Map<Integer, List<String>> viewCountryMap;
    
    private final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    
    // Private constructor for Singleton
    private CacheService() {
        Configuration config = new Configuration();
        CacheConfiguration cacheConfig = new CacheConfiguration("dataCache", 5000)
                .eternal(false)
                .timeToIdleSeconds(180)
                .timeToLiveSeconds(300)
                .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LRU);
        config.addCache(cacheConfig);
        cacheManager = CacheManager.newInstance(config);
        dataCache = cacheManager.getCache("dataCache");
        scheduleCacheRefresh();
        logger.info("CacheService initialized and cache refresh scheduled.");
    }

    public static synchronized CacheService getInstance() {
        if (instance == null) {
            instance = new CacheService();
        }
        return instance;
    }

    private void scheduleCacheRefresh() {
        timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                refreshAllCache();
            }
        }, 5000, 10 * 60 * 1000);
    }

    // Refresh all cached data
    public void refreshAllCache() {
        logger.info("Refreshing all cached data...");
        String currentDate = sdf.format(new Date());
        dataCache.removeAll();
        
        // Refreshes for each type and isNew combination
        for (String type : CacheConstants.RADAR_TYPES) {
            for (String isNew : CacheConstants.RADAR_IS_NEW) {
                for (Map.Entry<Integer, List<String>> entry : viewCountryMap.entrySet()) {
                    Integer viewId = entry.getKey();
                    List<String> countries = entry.getValue();
                    for (String country : countries) {
                        List<Integer> subViews = da.getSubViews(viewId)
                                .stream()
                                .map(Views::getId)
                                .collect(Collectors.toList());
                        for (Integer subViewId : subViews) {
                            getDataPerWeek(type, isNew, viewId, subViewId, country, viewNameMap.get(viewId), currentDate);
                            getCompCircleScore(type, viewId, subViewId, country, viewNameMap.get(viewId), currentDate);
                        }
                    }
                }
            }
        }
        logger.info("All caches refreshed.");
    }

    // Example implementation for data fetching and caching, similar to existing methods
    public List<ViewInfo> getDataPerWeek(String type, String isNew, int viewId, int subViewId, String country, String viewText, String date) {
        String cacheKey = generateCacheKey(type, isNew, viewId, country, date);
        return fetchDataAndCache(cacheKey, () -> da.getCoveragePerWeek(viewId, subViewId, country, type, viewText, date));
    }

    // A generic method to fetch data and cache it
    private <T> T fetchDataAndCache(String cacheKey, Supplier<T> dataSupplier) {
        Element cachedElement = dataCache.get(cacheKey);
        if (cachedElement != null) {
            logger.debug("Cache hit for key: {}", cacheKey);
            return (T) cachedElement.getObjectValue();
        }
        logger.debug("Cache miss for key: {}", cacheKey);
        T data = dataSupplier.get();
        dataCache.put(new Element(cacheKey, data));
        return data;
    }

    private String generateCacheKey(String type, String isNew, int viewId, String country, String date) {
        return type.toLowerCase() + "_" + isNew.toLowerCase() + "_" + viewId + "_" + country.toLowerCase() + "_" + date;
    }

    public void shutdown() {
        if (timer != null) {
            timer.cancel();
            logger.info("Cache refresh timer cancelled.");
        }
        cacheManager.shutdown();
        logger.info("CacheManager has been shut down.");
    }

    // Getters and Setters
    public void setViewCountryMap(Map<Integer, List<String>> viewCountryMap) {
        this.viewCountryMap = viewCountryMap;
    }

    public void setViewNameMap(Map<Integer, String> viewNameMap) {
        this.viewNameMap = viewNameMap;
    }
}
