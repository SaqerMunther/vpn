package com.app.dev.cmon.cache;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.Element;
import net.sf.ehcache.config.CacheConfiguration;
import net.sf.ehcache.config.Configuration;
import net.sf.ehcache.store.MemoryStoreEvictionPolicy;

import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.stream.Collectors;

import com.app.dev.cmon.components.AssetInfo;
import com.app.dev.cmon.components.ViewInfo;
import com.app.dev.cmon.components.Views;
import com.app.dev.cmon.controllers.DataAccess;
import com.app.dev.cmon.utilites.CacheConstants;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CacheService {
    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);
    private static CacheService instance;
    
    private CacheManager cacheManager;
    private Cache dataCache;
    private Timer timer;
    private DataAccess da = new DataAccess();
    
    private Map<Integer, String> viewNameMap;
    private Map<Integer, List<String>> viewCountryMap;
    
    private final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    
    // Private constructor for Singleton
    private CacheService() {
        Configuration config = new Configuration();
        // Set maximum entries to 1500 as required
        CacheConfiguration cacheConfig = new CacheConfiguration("dataCache", 1500)
                .eternal(false)
                .timeToIdleSeconds(180)
                .timeToLiveSeconds(300)
                .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LRU);
        config.addCache(cacheConfig);
        cacheManager = CacheManager.newInstance(config);
        dataCache = cacheManager.getCache("dataCache");
        scheduleCacheRefresh();
        logger.info("CacheService initialized and cache refresh scheduled.");
    }

    public static synchronized CacheService getInstance() {
        if (instance == null) {
            instance = new CacheService();
        }
        return instance;
    }

    private void scheduleCacheRefresh() {
        timer = new Timer();
        // Schedule cache refresh every 10 minutes with an initial delay of 5 seconds.
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                String date = sdf.format(new Date());
                refreshDataPerWeekCache(date);
            }
        }, 5000, 10 * 60 * 1000);
        logger.info("Cache refresh task scheduled to run every 10 minutes after an initial delay of 5 seconds.");
    }

    // Helper method to generate a cache key consistently
    private String generateCacheKey(String type, String isNew, int viewId, String country, String date) {
        return type.toLowerCase() + "_" + isNew.toLowerCase() + "_" + viewId + "_" + country.toLowerCase() + "_" + date;
    }
    
    // Refresh the entire cache (for all views) using the instance maps
    public void refreshDataPerWeekCache(String date) {
        logger.info("Refreshing dataCache...");
        dataCache.removeAll();
        logger.info("dataCache has been cleared.");
        
        for (String type : CacheConstants.RADAR_TYPES) {
            for (String isNew : CacheConstants.RADAR_IS_NEW) {
                for (Map.Entry<Integer, List<String>> entry : viewCountryMap.entrySet()) {
                    Integer viewId = entry.getKey();
                    List<String> countries = entry.getValue();
                    for (String country : countries) {
                        List<Integer> subViews = da.getSubViews(viewId)
                                .stream()
                                .map(Views::getId)
                                .collect(Collectors.toList());
                        for (Integer subViewId : subViews) {
                            String cacheKey = generateCacheKey(type, isNew, viewId, country, date);
                            logger.debug("Populating cache for key: {}", cacheKey);
                            List<ViewInfo> data = da.getCoveragePerWeek(viewId, subViewId,
                                    country.equalsIgnoreCase("all") ? "" : country,
                                    type, viewNameMap.get(viewId), date);
                            dataCache.put(new Element(cacheKey, data));
                            logger.info("Data for key: {} has been cached.", cacheKey);
                        }
                    }
                }
            }
        }
        logger.info("Current cache size after refresh: {}", dataCache.getSize());
    }
    
    // Preload cache in background without blocking the initial view load
    public void preloadCacheBackground(String date) {
        new Thread(() -> {
            logger.info("Starting background cache preloading.");
            refreshDataPerWeekCache(date);
            logger.info("Background cache preloading completed.");
        }).start();
    }

    // Retrieve data from cache or fetch and cache it if missing
    public List<ViewInfo> getDataPerWeek(String type, String isNew, int viewId, int subViewId, String country, String viewText, String date) {
        String cacheKey = generateCacheKey(type, isNew, viewId, country, date);
        logger.debug("Fetching data for cache key: {}", cacheKey);
        
        Element cachedElement = dataCache.get(cacheKey);
        if (cachedElement != null) {
            logger.info("Cache hit for key: {}", cacheKey);
            return (List<ViewInfo>) cachedElement.getObjectValue();
        }
        
        logger.info("Cache miss for key: {}. Fetching data from DataAccess.", cacheKey);
        List<ViewInfo> data = da.getCoveragePerWeek(viewId, subViewId,
                country.equalsIgnoreCase("all") ? "" : country,
                type, viewText, date);
        dataCache.put(new Element(cacheKey, data));
        logger.info("Data for key: {} has been cached.", cacheKey);
        logger.info("Current cache size: {}", dataCache.getSize());
        
        return data;
    }
    
    // Cache for getCompCircleScore method
    public List<ViewInfo> getCompCircleScore(String type, int viewId, int subViewId, String country, String viewText, String date) {
        String cacheKey = "compCircleScore_" + type + "_" + viewId + "_" + subViewId + "_" + country + "_" + date;
        logger.debug("Fetching data for cache key: {}", cacheKey);
        
        Element cachedElement = dataCache.get(cacheKey);
        if (cachedElement != null) {
            logger.info("Cache hit for key: {}", cacheKey);
            return (List<ViewInfo>) cachedElement.getObjectValue();
        }
        
        logger.info("Cache miss for key: {}. Fetching data from DataAccess.", cacheKey);
        List<ViewInfo> data = da.getComplyCirclePerScore(viewId, subViewId,
                country.equalsIgnoreCase("all") ? "" : country, type, viewText, date);
        dataCache.put(new Element(cacheKey, data));
        logger.info("Data for key: {} has been cached.", cacheKey);
        logger.info("Current cache size: {}", dataCache.getSize());
        
        return data;
    }
    
    // Cache for processAndMapData method
    public Map<String, Pair<Integer, Integer>> processAndMapData(int viewId, int subViewId, String country, String date) {
        String cacheKey = "processAndMapData_" + viewId + "_" + subViewId + "_" + country + "_" + date;
        logger.debug("Fetching data for cache key: {}", cacheKey);
        
        Element cachedElement = dataCache.get(cacheKey);
        if (cachedElement != null) {
            logger.info("Cache hit for key: {}", cacheKey);
            return (Map<String, Pair<Integer, Integer>>) cachedElement.getObjectValue();
        }
        
        logger.info("Cache miss for key: {}. Fetching data from DataAccess.", cacheKey);
        List<AssetInfo> listOne = da.getAllCoverage(viewId, -1, "", sdf.format(getPreviousMonth(1)));
        List<AssetInfo> listTwo = da.getAllCoverage(viewId, -1, "", sdf.format(getPreviousMonth(2)));
        
        Map<String, Pair<Integer, Integer>> oneMonthMap = processAssetList(listOne);
        Map<String, Pair<Integer, Integer>> twoMonthMap = processAssetList(listTwo);
        
        dataCache.put(new Element(cacheKey, oneMonthMap));
        dataCache.put(new Element(cacheKey, twoMonthMap));
        logger.info("Data for key: {} has been cached.", cacheKey);
        logger.info("Current cache size: {}", dataCache.getSize());
        
        return oneMonthMap;
    }
    
    private Date getPreviousMonth(int months) {
        LocalDate today = LocalDate.now();
        LocalDate resultDate = today.withDayOfMonth(1);
        switch (months) {
            case 1:
                resultDate = resultDate.minusMonths(1);
                break;
            case 2:
                resultDate = resultDate.minusMonths(2);
                break;
            case 3:
                resultDate = resultDate.minusMonths(3);
                break;
            default:
                throw new IllegalArgumentException("Invalid month value: " + months);
        }
        return Date.from(resultDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
    }
    
    private Map<String, Pair<Integer, Integer>> processAssetList(List<AssetInfo> assetList) {
        // Group by LocationCode + SubViewId
        Map<String, Pair<Integer, Integer>> resultMap = assetList.stream()
            .collect(Collectors.groupingBy(
                asset -> asset.getLocationCode() + asset.getSubViewId(),
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
            ));

        // Group by "ALL" location per SubViewId
        Map<String, Pair<Integer, Integer>> allGroupMapBySubViewId = assetList.stream()
            .collect(Collectors.groupingBy(
                asset -> "ALL" + asset.getSubViewId(),
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
            ));

        // Group by SubViewId = -1 for all locations
        Map<String, Pair<Integer, Integer>> allLocationsMap = assetList.stream()
            .collect(Collectors.groupingBy(
                asset -> asset.getLocationCode() + "-1",
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
            ));

        // Calculate the total for all data without grouping
        Pair<Integer, Integer> totalPair = assetList.stream()
            .collect(Collectors.collectingAndThen(
                Collectors.toList(),
                assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
            );

        // Add the "ALL" group to the result map
        resultMap.putAll(allGroupMapBySubViewId);

        // Add the all locations grouped by SubViewId = -1 to the result map
        resultMap.putAll(allLocationsMap);

        // Add the overall total to the result map
        resultMap.put("ALL" + "-1", totalPair);

        return resultMap;
    }
    
    public void shutdown() {
        if (timer != null) {
            timer.cancel();
            logger.info("Cache refresh timer cancelled.");
        }
        cacheManager.shutdown();
        logger.info("CacheManager has been shut down.");
    }

    // Getters and Setters for viewCountryMap and viewNameMap
    public Map<Integer, List<String>> getViewCountryMap() {
        return viewCountryMap;
    }

    public void setViewCountryMap(Map<Integer, List<String>> viewCountryMap) {
        this.viewCountryMap = viewCountryMap;
    }

    public Map<Integer, String> getViewNameMap() {
        return viewNameMap;
    }

    public void setViewNameMap(Map<Integer, String> viewNameMap) {
        this.viewNameMap = viewNameMap;
    }
}
