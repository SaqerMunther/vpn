package com.app.dev.cmon.cache;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.config.CacheConfiguration;
import net.sf.ehcache.config.Configuration;
import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.SimpleDateFormat;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.Date;

/**
 * CacheService is a singleton that provides caching operations.
 * It supports synchronous get/put operations and asynchronous preloading.
 */
public class CacheService {
    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);
    private static CacheService instance;
    
    private CacheManager cacheManager;
    private ICacheProvider cacheProvider;
    private ExecutorService executorService = Executors.newSingleThreadExecutor();
    private SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

    // Private constructor for singleton pattern.
    private CacheService() {
        Configuration config = new Configuration();
        CacheConfiguration cacheConfig = new CacheConfiguration("dataCache", 5000)
                .eternal(false)
                .timeToIdleSeconds(180)
                .timeToLiveSeconds(300)
                .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LRU);
        config.addCache(cacheConfig);
        cacheManager = CacheManager.newInstance(config);
        Cache dataCache = cacheManager.getCache("dataCache");
        cacheProvider = new EhcacheProvider(dataCache);
        logger.info("CacheService initialized.");
    }
    
    public static synchronized CacheService getInstance() {
        if (instance == null) {
            instance = new CacheService();
        }
        return instance;
    }
    
    /**
     * Returns the cached object for a given key.
     */
    public <T> T getFromCache(String key) {
        T value = cacheProvider.get(key);
        if (value != null) {
            logger.debug("Cache hit for key: {}", key);
        } else {
            logger.debug("Cache miss for key: {}", key);
        }
        return value;
    }
    
    /**
     * Puts a value in the cache using the specified key.
     */
    public <T> void putInCache(String key, T value) {
        cacheProvider.put(key, value);
        logger.info("Cached data for key: {} (cache size: {})", key, cacheProvider.size());
    }
    
    /**
     * Clears the cache.
     */
    public void clearCache() {
        cacheProvider.clear();
        logger.info("Cache cleared.");
    }
    
    /**
     * refreshAllCacheData() simulates refreshing multiple cache entries.
     * Replace the simulated calls with your actual DataAccess calls.
     */
    public void refreshAllCacheData(
            int viewId, int subViewId, String country, String viewText) {
        logger.info("Starting full cache refresh...");
        String dateStr = sdf.format(new Date());
        
        // Preload circle score data for "Comp"
        String keyCompCircle = "CompCircleScore_" + viewId + "_" + subViewId + "_" +
                (country.equalsIgnoreCase("all") ? "all" : country) + "_Comp_" +
                viewText + "_" + dateStr;
        // Simulate fetching data from DataAccess:
        // In your real code, call: da.getComplyCirclePerScore(...)
        Object compCircleData = simulateDataAccess("ComplyCirclePerScore", keyCompCircle);
        cacheProvider.put(keyCompCircle, compCircleData);
        
        // Preload weekly coverage data for "Cov"
        String keyDataPerWeekCov = "DataPerWeek_Cov_false_" + viewId + "_" + subViewId + "_" +
                (country.equalsIgnoreCase("all") ? "all" : country) + "_" +
                viewText + "_" + dateStr;
        Object weeklyCovData = simulateDataAccess("CoveragePerWeek", keyDataPerWeekCov);
        cacheProvider.put(keyDataPerWeekCov, weeklyCovData);
        
        // Preload weekly compliance data for "Comp"
        String keyDataPerWeekComp = "DataPerWeek_Comp_true_" + viewId + "_" + subViewId + "_" +
                (country.equalsIgnoreCase("all") ? "all" : country) + "_" +
                viewText + "_" + dateStr;
        Object weeklyCompData = simulateDataAccess("CoveragePerWeek", keyDataPerWeekComp);
        cacheProvider.put(keyDataPerWeekComp, weeklyCompData);
        
        // Preload processed maps (one-month and two-month)
        String keyOneMonth = "ProcessMap_OneMonth_" + viewId + "_" + subViewId + "_" +
                (country.equalsIgnoreCase("all") ? "all" : country) + "_" + dateStr;
        Object oneMonthMap = simulateDataAccess("ProcessMap_OneMonth", keyOneMonth);
        cacheProvider.put(keyOneMonth, oneMonthMap);
        
        String keyTwoMonth = "ProcessMap_TwoMonth_" + viewId + "_" + subViewId + "_" +
                (country.equalsIgnoreCase("all") ? "all" : country) + "_" + dateStr;
        Object twoMonthMap = simulateDataAccess("ProcessMap_TwoMonth", keyTwoMonth);
        cacheProvider.put(keyTwoMonth, twoMonthMap);
        
        logger.info("Full cache refresh completed.");
    }
    
    /**
     * preloadCacheBackground() launches the refreshAllCacheData routine asynchronously.
     * You must pass in the current view parameters.
     */
    public void preloadCacheBackground(
            final int viewId, final int subViewId, final String country, final String viewText) {
        executorService.submit(() -> {
            logger.info("Asynchronous cache preloading started.");
            refreshAllCacheData(viewId, subViewId, country, viewText);
            logger.info("Asynchronous cache preloading completed.");
        });
    }
    
    /**
     * A helper simulation method. Replace this with your real DataAccess calls.
     */
    private Object simulateDataAccess(String methodName, String key) {
        try {
            // Simulate a delay (e.g. 2 seconds) to represent a long data fetch.
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        // For simulation purposes, return a string indicating which data was fetched.
        return "Data[" + methodName + "] for key: " + key;
    }
    
    /**
     * Shuts down the executor and cache manager.
     */
    public void shutdown() {
        executorService.shutdown();
        cacheManager.shutdown();
        logger.info("CacheService shutdown.");
    }
}
