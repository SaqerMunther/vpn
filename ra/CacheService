package com.app.dev.cmon.cache;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import com.app.dev.cmon.components.ViewInfo;
import com.app.dev.cmon.components.Views;
import com.app.dev.cmon.controllers.DataAccess;
import com.app.dev.cmon.utilites.CacheConstants;

public class CacheService {
    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);
    private static CacheService instance;

    private ICacheProvider cacheProvider;
    private ExecutorService executorService = Executors.newSingleThreadExecutor();
    private ScheduledExecutorService scheduledExecutor;
    private SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    private DataAccess da = new DataAccess();
    private Map<Integer, List<String>> viewCountryMap;
    private Map<Integer, String> viewNameMap;
    private Date date = new Date();
    private CacheConfig cacheConfig;
    
    private int errorCount = 0; // Counter for errors
    private boolean cacheEnabled = true; // Flag to control cache updates

    // Cache for subViews, to avoid repeated data source calls.
    private final Map<Integer, List<Integer>> subViewsCache = new ConcurrentHashMap<>();

    private CacheService() {
        cacheConfig = new CacheConfig();
        cacheProvider = new EhcacheProvider(cacheConfig.getDataCache());
        logger.debug("CacheService initialized.");
    }

    public static synchronized CacheService getInstance() {
        if (instance == null) {
            instance = new CacheService();
        }
        return instance;
    }
    
    public void setViewCountryMap(Map<Integer, List<String>> viewCountryMap) {
        this.viewCountryMap = viewCountryMap;
    }
    
    public void setViewNameMap(Map<Integer, String> viewNameMap) {
        this.viewNameMap = viewNameMap;
    }
    
    public void setDate(Date date) {
        this.date = date;
    }

    public String getCacheKey(String methodName, String extra, int viewId, String country, String date) {
        return (methodName + "_" + extra + "_" + viewId + "_" + (country.equalsIgnoreCase("") ? "all" : country) + "_" + date).toLowerCase();
    }

    public <T> T getFromCache(String key) {
        T value = cacheProvider.get(key);
        return value;
    }

    public <T> void putInCache(String key, T value) {
        cacheProvider.put(key, value);
    }

    public void clearCache() {
        cacheProvider.clear();
        logger.info("Cache cleared.");
    }

    /**
     * Refresh both DataPerWeek and CompCircleScore caches.
     */
    public void refreshAllCacheData(String dateStr) {
        logger.info("Refreshing dataCache dynamically...");
        clearCache();

        // Process DataPerWeek caches in parallel for RADAR_TYPES and RADAR_IS_NEW combinations.
        Arrays.stream(CacheConstants.RADAR_TYPES).forEach(type ->
            Arrays.stream(CacheConstants.RADAR_IS_NEW).forEach(isNew -> {
                viewCountryMap.forEach((vid, countries) -> {
                    // Retrieve or cache the subviews list
                    List<Integer> subViews = subViewsCache.computeIfAbsent(vid, v -> 
                        da.getSubViews(v).stream().map(Views::getId).collect(Collectors.toList())
                    );
                    countries.forEach(country -> {
                        subViews.forEach(subViewId -> {
                            if (!cacheEnabled) {
                                logger.error("Cache updates are disabled. Exiting loop.");
                                return;
                            }
                            try {
                                String key = getCacheKey("DataPerWeek", type + "_" + isNew, vid, country, dateStr);
                                List<ViewInfo> data = da.getCoveragePerWeek(
                                        vid, subViewId,
                                        country.equalsIgnoreCase("all") ? "" : country,
                                        type, viewNameMap.get(vid), dateStr);
                                cacheProvider.put(key, data);
                            } catch (Exception e) {
                                logger.error("Error refreshing DataPerWeek for viewId {} country {}: {}", vid, country, e.getMessage());
                                incrementErrorCount();
                            }
                        });
                    });
                });
            })
        );

        // Process CompCircleScore caches in parallel.
        viewCountryMap.forEach((vid, countries) -> {
            // Retrieve or cache the subviews list
            List<Integer> subViews = subViewsCache.computeIfAbsent(vid, v ->
                da.getSubViews(v).stream().map(Views::getId).collect(Collectors.toList())
            );
            countries.forEach(country -> {
                subViews.forEach(subViewId -> {
                    if (!cacheEnabled) {
                        logger.error("Cache updates are disabled. Exiting loop.");
                        return;
                    }
                    try {
                        String key = getCacheKey("CompCircleScore", "Comp", vid, country, dateStr);
                        List<ViewInfo> data = da.getComplyCirclePerScore(
                                vid, subViewId,
                                country.equalsIgnoreCase("all") ? "" : country,
                                "Comp", viewNameMap.get(vid), dateStr);
                        cacheProvider.put(key, data);
                    } catch (Exception e) {
                        logger.error("Error refreshing CompCircleScore for viewId {} country {}: {}", vid, country, e.getMessage());
                        incrementErrorCount();
                    }
                });
            });
        });

        logger.info("Dynamic cache refresh complete. Current cache size: {}", cacheProvider.size());
    }

    public void preloadCacheBackground(final int viewId, final int subViewId,
                                         final String country, final String viewText) {
        final String dateStr = sdf.format(date);
        executorService.submit(() -> {
            errorCount = 0;
            cacheEnabled = true;
            logger.info("Asynchronous cache preloading started.");
            refreshAllCacheData(dateStr);
            logger.info("Asynchronous cache preloading completed.");
        });
    }

    public void startAutoRefresh(final int viewId, final int subViewId, final String country, final String viewText) {
        if (scheduledExecutor == null || scheduledExecutor.isShutdown()) {
            scheduledExecutor = Executors.newSingleThreadScheduledExecutor();
        }
        int interval = cacheConfig.getAutoRefreshInterval();
        scheduledExecutor.scheduleAtFixedRate(() -> {
            String dateStr = sdf.format(date);
            logger.debug("Automatic periodic cache refresh triggered.");
            refreshAllCacheData(dateStr);
        }, interval, interval, TimeUnit.MINUTES);
    }

    public void stopAutoRefresh() {
        if (scheduledExecutor != null && !scheduledExecutor.isShutdown()) {
            scheduledExecutor.shutdown();
            logger.debug("Automatic cache auto-refresh stopped.");
        }
    }

    public void shutdown() {
        executorService.shutdown();
        if (scheduledExecutor != null) {
            scheduledExecutor.shutdown();
        }
        cacheConfig.shutdown();
        logger.debug("CacheService shutdown.");
    }

    public void startupFlow(final int viewId, final int subViewId, final String country, final String viewText) {
        preloadCacheBackground(viewId, subViewId, country, viewText);
        startAutoRefresh(viewId, subViewId, country, viewText);
        logger.debug("CacheService startup flow completed.");
    }
    
    public void incrementErrorCount() {
        errorCount++;
        logger.error("An error occurred. Current error count: {}", errorCount);
        if (errorCount > cacheConfig.getErrorLimit()) {
            cacheEnabled = false; // Disable cache updates if too many errors occur
            logger.error("Error limit exceeded. Cache updates are now disabled.");
        }
    }
}


////////////////////////////////////////////////////////////////////

package com.app.dev.cmon.cache;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.config.CacheConfiguration;
import net.sf.ehcache.config.Configuration;
import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class CacheConfig {
    private static final Logger logger = LoggerFactory.getLogger(CacheConfig.class);
    private CacheManager cacheManager;
    private Properties properties = new Properties();
    private int autoRefreshInterval;
    private int errorLimit = 10;

    public CacheConfig() {
        loadProperties();
        Configuration config = new Configuration();
        CacheConfiguration cacheConfig = new CacheConfiguration("dataCache", 2000)
                .eternal(false)
                .timeToIdleSeconds(1800) // 30 minutes
                .timeToLiveSeconds(1800) // 30 minutes
                .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LRU);
        config.addCache(cacheConfig);
        cacheManager = CacheManager.newInstance(config);
        logger.debug("CacheConfig initialized.");
    }

    private void loadProperties() {
        try (InputStream input = getClass().getClassLoader().getResourceAsStream("application.properties")) {
            if (input == null) {
                logger.warn("Unable to find application.properties. Using default settings.");
                autoRefreshInterval = 30;
                return;
            }
            properties.load(input);
            String interval = properties.getProperty("cache.autoRefresh.interval", "30");
            String error = properties.getProperty("cache.errorLimit.interval", "10");
            autoRefreshInterval = Integer.parseInt(interval);
            errorLimit = Integer.parseInt(error);
        } catch (IOException ex) {
            logger.error("Error loading properties: {}", ex.getMessage());
            autoRefreshInterval = 30;
            errorLimit = 10;
        }
    }

    public Cache getDataCache() {
        return cacheManager.getCache("dataCache");
    }

    public int getAutoRefreshInterval() {
        return autoRefreshInterval;
    }

    public int getErrorLimit() {
        return errorLimit;
    }

    public void setErrorLimit(int errorLimit) {
        this.errorLimit = errorLimit;
    }

    public void shutdown() {
        cacheManager.shutdown();
        logger.debug("CacheConfig shutdown.");
    }
}

