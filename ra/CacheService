package com.app.dev.cmon.cache;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.config.CacheConfiguration;
import net.sf.ehcache.config.Configuration;
import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
import net.sf.ehcache.Element;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.SimpleDateFormat;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.Date;

import com.app.dev.cmon.components.ViewInfo;
import com.app.dev.cmon.components.AssetInfo;
import com.app.dev.cmon.components.Views;
import com.app.dev.cmon.controllers.DataAccess;
import com.app.dev.cmon.utilites.CacheConstants;
import com.arabbank.dev.utility.Pair;

/**
 * CacheService provides a dynamic caching layer. It uses an Ehcache instance (via ICacheProvider)
 * and supports:
 *   - Synchronous get/put operations with unique keys.
 *   - A dynamic refresh method that loops over all key combinations.
 *   - A one–time asynchronous preload.
 *   - Automatic periodic refresh every 20 minutes.
 */
public class CacheService {
    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);
    private static CacheService instance;
    
    private CacheManager cacheManager;
    private ICacheProvider cacheProvider;
    
    // Executor for one–time asynchronous tasks.
    private ExecutorService executorService = Executors.newSingleThreadExecutor();
    // Scheduled executor for periodic auto–refresh.
    private ScheduledExecutorService scheduledExecutor;
    
    private SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    
    // DataAccess instance for fetching data.
    private DataAccess da = new DataAccess();
    
    // Dynamic parameters that need to be set by the controller.
    private Map<Integer, List<String>> viewCountryMap;
    private Map<Integer, String> viewNameMap;
    
    // Private constructor.
    private CacheService() {
        Configuration config = new Configuration();
        CacheConfiguration cacheConfig = new CacheConfiguration("dataCache", 5000)
                .eternal(false)
                .timeToIdleSeconds(180)
                .timeToLiveSeconds(300)
                .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LRU);
        config.addCache(cacheConfig);
        cacheManager = CacheManager.newInstance(config);
        Cache dataCache = cacheManager.getCache("dataCache");
        cacheProvider = new EhcacheProvider(dataCache);
        logger.info("CacheService initialized.");
    }
    
    public static synchronized CacheService getInstance() {
        if (instance == null) {
            instance = new CacheService();
        }
        return instance;
    }
    
    // Setter methods for dynamic parameters.
    public void setViewCountryMap(Map<Integer, List<String>> viewCountryMap) {
        this.viewCountryMap = viewCountryMap;
    }
    
    public void setViewNameMap(Map<Integer, String> viewNameMap) {
        this.viewNameMap = viewNameMap;
    }
    
    /**
     * Retrieves an object from the cache by key.
     */
    public <T> T getFromCache(String key) {
        T value = cacheProvider.get(key);
        if (value != null) {
            logger.debug("Cache hit for key: {}", key);
        } else {
            logger.debug("Cache miss for key: {}", key);
        }
        return value;
    }
    
    /**
     * Puts a value into the cache under the given key.
     */
    public <T> void putInCache(String key, T value) {
        cacheProvider.put(key, value);
        logger.info("Cached data for key: {} (cache size: {})", key, cacheProvider.size());
    }
    
    /**
     * Clears the cache.
     */
    public void clearCache() {
        cacheProvider.clear();
        logger.info("Cache cleared.");
    }
    
    /**
     * Generates a unique cache key based on parameters.
     */
    private String generateCacheKey(String methodName, String extra, int viewId, String country, String date) {
        // methodName: e.g., "CoveragePerWeek", "CompCircleScore", "ProcessMap_OneMonth"
        // extra: may be used for additional info (e.g., "cov" or "comp" or "true"/"false")
        return methodName.toLowerCase() + "_" + extra.toLowerCase() + "_" + viewId + "_" +
                country.toLowerCase() + "_" + date;
    }
    
    /**
     * Dynamic refresh method: Loops through all combinations of parameters for all methods.
     * In this example, we refresh keys for:
     *   (a) Coverage Per Week (used in getDataPerWeek)
     *   (b) Comply Circle Score (used in getCompCircleScore)
     *   (c) Process Map (for one-month and two-month data)
     * 
     * @param date The current date string.
     */
    public void refreshAllCacheData(String date) {
        logger.info("Refreshing dataCache dynamically...");
        clearCache(); // Optionally clear cache first.
        
        // (a) Refresh Coverage Per Week for all combinations.
        for (String type : CacheConstants.RADAR_TYPES) {
            for (String isNew : CacheConstants.RADAR_IS_NEW) {
                for (Map.Entry<Integer, List<String>> entry : viewCountryMap.entrySet()) {
                    int vid = entry.getKey();
                    List<String> countries = entry.getValue();
                    for (String country : countries) {
                        // For each view, get subviews.
                        List<Integer> subViews = da.getSubViews(vid)
                                .stream()
                                .map(Views::getId)
                                .collect(Collectors.toList());
                        for (Integer subViewId : subViews) {
                            String key = generateCacheKey("CoveragePerWeek", type + "_" + isNew, vid, country, date);
                            logger.debug("Populating CoveragePerWeek cache for key: {}", key);
                            List<ViewInfo> data = da.getCoveragePerWeek(vid, subViewId,
                                    country.equalsIgnoreCase("all") ? "" : country,
                                    type, viewNameMap.get(vid), date);
                            cacheProvider.put(key, data);
                            logger.info("Cached CoveragePerWeek for key: {}", key);
                        }
                    }
                }
            }
        }
        
        // (b) Refresh Comply Circle Score data.
        // Assume we want to refresh for a fixed type (e.g., "Comp").
        String compType = "Comp";
        for (Map.Entry<Integer, List<String>> entry : viewCountryMap.entrySet()) {
            int vid = entry.getKey();
            List<String> countries = entry.getValue();
            for (String country : countries) {
                // Again, loop through subviews.
                List<Integer> subViews = da.getSubViews(vid)
                        .stream()
                        .map(Views::getId)
                        .collect(Collectors.toList());
                for (Integer subViewId : subViews) {
                    String key = generateCacheKey("CompCircleScore", compType, vid, country, date);
                    logger.debug("Populating CompCircleScore cache for key: {}", key);
                    List<ViewInfo> data = da.getComplyCirclePerScore(vid, subViewId,
                            country.equalsIgnoreCase("all") ? "" : country,
                            compType, viewNameMap.get(vid), date);
                    cacheProvider.put(key, data);
                    logger.info("Cached CompCircleScore for key: {}", key);
                }
            }
        }
        
        // (c) Refresh Process Map for one-month and two-month data.
        for (Map.Entry<Integer, List<String>> entry : viewCountryMap.entrySet()) {
            int vid = entry.getKey();
            List<String> countries = entry.getValue();
            for (String country : countries) {
                // For process maps, subViewId is -1 (aggregated).
                String keyOne = generateCacheKey("ProcessMap_OneMonth", "", vid, country, date);
                List<AssetInfo> listOne = da.getAllCoverage(vid, -1, "", sdf.format(getPreviousMonth(1)));
                Map<String, Pair<Integer, Integer>> oneMap = processAssetList(listOne);
                cacheProvider.put(keyOne, oneMap);
                logger.info("Cached ProcessMap_OneMonth for key: {}", keyOne);
                
                String keyTwo = generateCacheKey("ProcessMap_TwoMonth", "", vid, country, date);
                List<AssetInfo> listTwo = da.getAllCoverage(vid, -1, "", sdf.format(getPreviousMonth(2)));
                Map<String, Pair<Integer, Integer>> twoMap = processAssetList(listTwo);
                cacheProvider.put(keyTwo, twoMap);
                logger.info("Cached ProcessMap_TwoMonth for key: {}", keyTwo);
            }
        }
        
        logger.info("Dynamic cache refresh complete. Current cache size: {}", cacheProvider.size());
    }
    
    /**
     * A helper to process an asset list into a map.
     * (This is similar to your original processAssetList.)
     */
    private Map<String, Pair<Integer, Integer>> processAssetList(List<AssetInfo> assetList) {
        Map<String, Pair<Integer, Integer>> resultMap = assetList.stream()
            .collect(Collectors.groupingBy(
                asset -> asset.getLocationCode() + asset.getSubViewId(),
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
                )
            ));
        // Additional grouping logic (for "ALL" groups) can be added here if needed.
        return resultMap;
    }
    
    /**
     * Preloads cache in the background (one–time asynchronous preload).
     * Typically called after serving the first view.
     */
    public void preloadCacheBackground(final int viewId, final int subViewId,
                                         final String country, final String viewText) {
        final String dateStr = sdf.format(new Date());
        executorService.submit(() -> {
            logger.info("Asynchronous cache preloading started.");
            refreshAllCacheData(dateStr);
            logger.info("Asynchronous cache preloading completed.");
        });
    }
    
    /**
     * Starts an automatic periodic refresh every 20 minutes.
     * Call this once (e.g. at application startup or after serving the first view).
     */
    public void startAutoRefresh(final int viewId, final int subViewId,
                                 final String country, final String viewText) {
        if (scheduledExecutor == null || scheduledExecutor.isShutdown()) {
            scheduledExecutor = Executors.newSingleThreadScheduledExecutor();
        }
        // Schedule the refresh every 20 minutes (initial delay 20 minutes).
        scheduledExecutor.scheduleAtFixedRate(() -> {
            String dateStr = sdf.format(new Date());
            logger.info("Automatic periodic cache refresh triggered.");
            refreshAllCacheData(dateStr);
        }, 20, 20, TimeUnit.MINUTES);
    }
    
    /**
     * Stops the automatic refresh.
     */
    public void stopAutoRefresh() {
        if (scheduledExecutor != null && !scheduledExecutor.isShutdown()) {
            scheduledExecutor.shutdown();
            logger.info("Automatic cache auto-refresh stopped.");
        }
    }
    
    /**
     * Shuts down all executors and the cache manager.
     */
    public void shutdown() {
        executorService.shutdown();
        if (scheduledExecutor != null) {
            scheduledExecutor.shutdown();
        }
        cacheManager.shutdown();
        logger.info("CacheService shutdown.");
    }
    
    /**
     * Helper: Returns a Date corresponding to "months" ago (using current date).
     */
    private Date getPreviousMonth(int months) {
        // (Simplified using Calendar)
        java.util.Calendar cal = java.util.Calendar.getInstance();
        cal.add(java.util.Calendar.MONTH, -months);
        cal.set(java.util.Calendar.DAY_OF_MONTH, 1);
        return cal.getTime();
    }
}



////////////////////////////////////////////////////////////////////

package com.app.dev.cmon.cache;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.config.CacheConfiguration;
import net.sf.ehcache.config.Configuration;
import net.sf.ehcache.store.MemoryStoreEvictionPolicy;
import net.sf.ehcache.Element;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.SimpleDateFormat;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.Date;

import com.app.dev.cmon.components.ViewInfo;
import com.app.dev.cmon.components.AssetInfo;
import com.app.dev.cmon.components.Views;
import com.app.dev.cmon.controllers.DataAccess;
import com.app.dev.cmon.utilites.CacheConstants;
import com.arabbank.dev.utility.Pair;

/**
 * CacheService provides dynamic caching operations.
 * It wraps an Ehcache instance (via ICacheProvider) and supports:
 *   - Synchronous get/put operations using unique keys.
 *   - A dynamic refresh that loops through all key combinations.
 *   - A one–time asynchronous preload.
 *   - Automatic periodic refresh every 20 minutes.
 *   - A startupFlow() method so that the CacheService handles its own initialization.
 */
public class CacheService {
    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);
    private static CacheService instance;
    
    private CacheManager cacheManager;
    private ICacheProvider cacheProvider;
    
    // Executor for one–time asynchronous tasks.
    private ExecutorService executorService = Executors.newSingleThreadExecutor();
    // Scheduled executor for periodic auto–refresh.
    private ScheduledExecutorService scheduledExecutor;
    
    private SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    
    // DataAccess instance for fetching data.
    private DataAccess da = new DataAccess();
    
    // Dynamic parameters provided by the application.
    private Map<Integer, List<String>> viewCountryMap;
    private Map<Integer, String> viewNameMap;
    
    // Private constructor.
    private CacheService() {
        Configuration config = new Configuration();
        CacheConfiguration cacheConfig = new CacheConfiguration("dataCache", 5000)
                .eternal(false)
                .timeToIdleSeconds(180)
                .timeToLiveSeconds(300)
                .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LRU);
        config.addCache(cacheConfig);
        cacheManager = CacheManager.newInstance(config);
        Cache dataCache = cacheManager.getCache("dataCache");
        cacheProvider = new EhcacheProvider(dataCache);
        logger.info("CacheService initialized.");
    }
    
    public static synchronized CacheService getInstance() {
        if (instance == null) {
            instance = new CacheService();
        }
        return instance;
    }
    
    // Setter methods so that the controller can provide the current dynamic parameters.
    public void setViewCountryMap(Map<Integer, List<String>> viewCountryMap) {
        this.viewCountryMap = viewCountryMap;
    }
    
    public void setViewNameMap(Map<Integer, String> viewNameMap) {
        this.viewNameMap = viewNameMap;
    }
    
    /**
     * Retrieves an object from the cache using a given key.
     */
    public <T> T getFromCache(String key) {
        T value = cacheProvider.get(key);
        if (value != null) {
            logger.debug("Cache hit for key: {}", key);
        } else {
            logger.debug("Cache miss for key: {}", key);
        }
        return value;
    }
    
    /**
     * Puts a value into the cache under the specified key.
     */
    public <T> void putInCache(String key, T value) {
        cacheProvider.put(key, value);
        logger.info("Cached value for key: {} (cache size: {})", key, cacheProvider.size());
    }
    
    /**
     * Clears the entire cache.
     */
    public void clearCache() {
        cacheProvider.clear();
        logger.info("Cache cleared.");
    }
    
    /**
     * Generates a unique key based on the method name, extra information, viewId, country, and date.
     */
    private String generateCacheKey(String methodName, String extra, int viewId, String country, String date) {
        return methodName.toLowerCase() + "_" + extra.toLowerCase() + "_" + viewId + "_" +
               country.toLowerCase() + "_" + date;
    }
    
    /**
     * refreshAllCacheData() loops over all parameter combinations for various caching methods.
     * In this example, it refreshes:
     *   (a) CoveragePerWeek data,
     *   (b) CompCircleScore data, and
     *   (c) ProcessMap data for one-month and two-month.
     *
     * @param date The current date as a string.
     */
    public void refreshAllCacheData(String date) {
        logger.info("Refreshing dataCache dynamically...");
        clearCache(); // Clear existing cache if desired.
        
        // (a) Refresh CoveragePerWeek data.
        for (String type : CacheConstants.RADAR_TYPES) {
            for (String isNew : CacheConstants.RADAR_IS_NEW) {
                for (Map.Entry<Integer, List<String>> entry : viewCountryMap.entrySet()) {
                    int vid = entry.getKey();
                    List<String> countries = entry.getValue();
                    for (String country : countries) {
                        List<Integer> subViews = da.getSubViews(vid)
                                .stream()
                                .map(Views::getId)
                                .collect(Collectors.toList());
                        for (Integer subViewId : subViews) {
                            String key = generateCacheKey("CoveragePerWeek", type + "_" + isNew, vid, country, date);
                            logger.debug("Populating CoveragePerWeek cache for key: {}", key);
                            List<ViewInfo> data = da.getCoveragePerWeek(vid, subViewId,
                                    country.equalsIgnoreCase("all") ? "" : country,
                                    type, viewNameMap.get(vid), date);
                            cacheProvider.put(key, data);
                            logger.info("Cached CoveragePerWeek for key: {}", key);
                        }
                    }
                }
            }
        }
        
        // (b) Refresh CompCircleScore data.
        String compType = "Comp";
        for (Map.Entry<Integer, List<String>> entry : viewCountryMap.entrySet()) {
            int vid = entry.getKey();
            List<String> countries = entry.getValue();
            for (String country : countries) {
                List<Integer> subViews = da.getSubViews(vid)
                        .stream()
                        .map(Views::getId)
                        .collect(Collectors.toList());
                for (Integer subViewId : subViews) {
                    String key = generateCacheKey("CompCircleScore", compType, vid, country, date);
                    logger.debug("Populating CompCircleScore cache for key: {}", key);
                    List<ViewInfo> data = da.getComplyCirclePerScore(vid, subViewId,
                            country.equalsIgnoreCase("all") ? "" : country,
                            compType, viewNameMap.get(vid), date);
                    cacheProvider.put(key, data);
                    logger.info("Cached CompCircleScore for key: {}", key);
                }
            }
        }
        
        // (c) Refresh ProcessMap data for one-month and two-month.
        for (Map.Entry<Integer, List<String>> entry : viewCountryMap.entrySet()) {
            int vid = entry.getKey();
            List<String> countries = entry.getValue();
            for (String country : countries) {
                // For one-month.
                String keyOne = generateCacheKey("ProcessMap_OneMonth", "", vid, country, date);
                List<AssetInfo> listOne = da.getAllCoverage(vid, -1, "", sdf.format(getPreviousMonth(1)));
                Map<String, Pair<Integer, Integer>> oneMap = processAssetList(listOne);
                cacheProvider.put(keyOne, oneMap);
                logger.info("Cached ProcessMap_OneMonth for key: {}", keyOne);
                
                // For two-month.
                String keyTwo = generateCacheKey("ProcessMap_TwoMonth", "", vid, country, date);
                List<AssetInfo> listTwo = da.getAllCoverage(vid, -1, "", sdf.format(getPreviousMonth(2)));
                Map<String, Pair<Integer, Integer>> twoMap = processAssetList(listTwo);
                cacheProvider.put(keyTwo, twoMap);
                logger.info("Cached ProcessMap_TwoMonth for key: {}", keyTwo);
            }
        }
        logger.info("Dynamic cache refresh complete. Current cache size: {}", cacheProvider.size());
    }
    
    /**
     * Helper method to process an asset list into a map.
     */
    private Map<String, Pair<Integer, Integer>> processAssetList(List<AssetInfo> assetList) {
        Map<String, Pair<Integer, Integer>> resultMap = assetList.stream()
            .collect(Collectors.groupingBy(
                asset -> asset.getLocationCode() + asset.getSubViewId(),
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
                )
            ));
        return resultMap;
    }
    
    /**
     * preloadCacheBackground() launches a one–time asynchronous refresh.
     * Typically called after the first view is served.
     */
    public void preloadCacheBackground(final int viewId, final int subViewId,
                                         final String country, final String viewText) {
        final String dateStr = sdf.format(new Date());
        executorService.submit(() -> {
            logger.info("Asynchronous cache preloading started.");
            refreshAllCacheData(dateStr);
            logger.info("Asynchronous cache preloading completed.");
        });
    }
    
    /**
     * startAutoRefresh() schedules automatic periodic refresh every 20 minutes.
     */
    public void startAutoRefresh(final int viewId, final int subViewId,
                                 final String country, final String viewText) {
        if (scheduledExecutor == null || scheduledExecutor.isShutdown()) {
            scheduledExecutor = Executors.newSingleThreadScheduledExecutor();
        }
        scheduledExecutor.scheduleAtFixedRate(() -> {
            String dateStr = sdf.format(new Date());
            logger.info("Automatic periodic cache refresh triggered.");
            refreshAllCacheData(dateStr);
        }, 20, 20, TimeUnit.MINUTES);
    }
    
    /**
     * shutdown() shuts down all executors and the cache manager.
     */
    public void shutdown() {
        executorService.shutdown();
        if (scheduledExecutor != null) {
            scheduledExecutor.shutdown();
        }
        cacheManager.shutdown();
        logger.info("CacheService shutdown.");
    }
    
    /**
     * getPreviousMonth() returns a Date corresponding to 'months' ago.
     */
    private Date getPreviousMonth(int months) {
        java.util.Calendar cal = java.util.Calendar.getInstance();
        cal.add(java.util.Calendar.MONTH, -months);
        cal.set(java.util.Calendar.DAY_OF_MONTH, 1);
        return cal.getTime();
    }
    
    /**
     * startupFlow() encapsulates the complete startup logic inside CacheService.
     * It should be called once during application startup.
     * Dynamic parameters (viewId, subViewId, country, viewText) are provided by the controller
     * via setters before calling startupFlow().
     */
    public void startupFlow(final int viewId, final int subViewId, final String country, final String viewText) {
        // Optionally, preload the cache asynchronously.
        preloadCacheBackground(viewId, subViewId, country, viewText);
        // Start automatic periodic refresh every 20 minutes.
        startAutoRefresh(viewId, subViewId, country, viewText);
        logger.info("CacheService startup flow completed.");
    }
}
