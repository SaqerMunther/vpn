package com.app.dev.cmon.cache;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import com.app.dev.cmon.components.ViewInfo;
import com.app.dev.cmon.controllers.DataAccess;
import com.app.dev.cmon.utilites.CacheConstants;

public class CacheService {
    private static final Logger logger = LoggerFactory.getLogger(CacheService.class);
    private static CacheService instance;

    private ICacheProvider cacheProvider;
    private DataAccess da = new DataAccess();
    private Map<Integer, List<String>> viewCountryMap;
    private Map<Integer, String> viewNameMap;
    private Date date = new Date();
    private CacheConfig cacheConfig;
    
    private int errorCount = 0; // Counter for errors
    private boolean cacheEnabled = true; // Flag to control cache updates

    private SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    private final java.util.concurrent.ExecutorService executorService = java.util.concurrent.Executors.newSingleThreadExecutor();
    private java.util.concurrent.ScheduledExecutorService scheduledExecutor;
    
    private CacheService() {
        cacheConfig = new CacheConfig();
        cacheProvider = new EhcacheProvider(cacheConfig.getDataCache());
        logger.info("CacheService initialized.");
    }

    public static synchronized CacheService getInstance() {
        if (instance == null) {
            instance = new CacheService();
        }
        return instance;
    }
    
    public void setViewCountryMap(Map<Integer, List<String>> viewCountryMap) {
        this.viewCountryMap = viewCountryMap;
        logger.info("View country map set with {} entries.", viewCountryMap.size());
    }
    
    public void setViewNameMap(Map<Integer, String> viewNameMap) {
        this.viewNameMap = viewNameMap;
        logger.info("View name map set with {} entries.", viewNameMap.size());
    }
    
    public void setDate(Date date) {
        this.date = date;
        logger.info("Cache date set to {}.", sdf.format(date));
    }

    /**
     * Generate a cache key.
     * For aggregated rows we append suffixes (e.g., "_sv_", "_ctry", "_overall_").
     */
    public String getCacheKey(String methodName, String extra, int viewId, String country, String date) {
        return (methodName + "_" + extra + "_" + viewId + "_" +
               (country.equalsIgnoreCase("") ? "all" : country) + "_" + date).toLowerCase();
    }

    public <T> T getFromCache(String key) {
        return cacheProvider.get(key);
    }

    public <T> void putInCache(String key, T value) {
        cacheProvider.put(key, value);
        logger.info("Cache entry saved: key = {}", key);
    }

    public void clearCache() {
        cacheProvider.clear();
        logger.info("Cache cleared.");
    }

    /**
     * Refreshes both DataPerWeek and CompCircleScore caches.
     * For each viewId, we retrieve detailed data for all countries and sub-view IDs,
     * partition the results, and then aggregate:
     *  - Detailed partitions: stored under keys including actual country and subViewID.
     *  - Aggregated per sub-view: (country "all" for each subViewID).
     *  - Aggregated per country: (subViewID = -1 for each country).
     *  - Overall aggregated: (country "all" and subViewID = -1).
     */
    public void refreshAllCacheData(String dateStr) {
        logger.info("Refreshing dataCache dynamically at {}...", dateStr);
        clearCache();

        // Process DataPerWeek caches for each combination of radar type and isNew.
        CacheConstants.RADAR_TYPES.forEach(type ->
            CacheConstants.RADAR_IS_NEW.forEach(isNew -> {
                viewCountryMap.keySet().forEach(vid -> {
                    try {
                        logger.info("Refreshing DataPerWeek for viewId {} (type: {}, isNew: {})", vid, type, isNew);
                        // Retrieve detailed records covering all countries and sub-view IDs.
                        List<ViewInfo> rawData = da.getCoveragePerWeekAll(vid, type, viewNameMap.get(vid), dateStr, isNew);
                        logger.info("Retrieved {} detailed records for viewId {}.", rawData.size(), vid);
                        
                        // Partition detailed records by country and sub-view.
                        Map<String, Map<Integer, List<ViewInfo>>> partitioned = rawData.stream()
                            .collect(Collectors.groupingBy(ViewInfo::getCountry,
                                Collectors.groupingBy(ViewInfo::getSupViewID)));
                        
                        // Cache each individual partition.
                        partitioned.forEach((country, subMap) -> {
                            subMap.forEach((subViewId, list) -> {
                                String key = getCacheKey("DataPerWeek", type + "_" + isNew, vid, country, dateStr)
                                             + "_sv_" + subViewId;
                                cacheProvider.put(key, list);
                                logger.info("Cached {} records for viewId {} for country {} and subViewID {}.", list.size(), vid, country, subViewId);
                            });
                        });
                        
                        // Aggregate per sub-view (across countries).
                        List<ViewInfo> aggBySubView = CacheDataProcessor.aggregateBySubView(rawData);
                        aggBySubView.forEach(vi -> {
                            String key = getCacheKey("DataPerWeek", type + "_" + isNew, vid, "all", dateStr)
                                         + "_sv_" + vi.getSupViewID();
                            cacheProvider.put(key, vi);
                            logger.info("Cached aggregated sub-view record for viewId {} for subViewID {}.", vid, vi.getSupViewID());
                        });
                        
                        // Aggregate per country (across sub-views).
                        List<ViewInfo> aggByCountry = CacheDataProcessor.aggregateByCountry(rawData);
                        aggByCountry.forEach(vi -> {
                            String key = getCacheKey("DataPerWeek", type + "_" + isNew, vid, vi.getCountry(), dateStr)
                                         + "_ctry";
                            cacheProvider.put(key, vi);
                            logger.info("Cached aggregated country record for viewId {} for country {}.", vid, vi.getCountry());
                        });
                        
                        // Overall aggregation.
                        List<ViewInfo> overallAgg = CacheDataProcessor.aggregateOverall(rawData);
                        overallAgg.forEach(vi -> {
                            String key = getCacheKey("DataPerWeek", type + "_" + isNew, vid, "all", dateStr)
                                         + "_overall_" + vi.getType();
                            cacheProvider.put(key, vi);
                            logger.info("Cached overall aggregated record for viewId {} for type {}.", vid, vi.getType());
                        });
                    } catch (Exception e) {
                        logger.error("Error refreshing DataPerWeek for viewId {}: {}", vid, e.getMessage());
                        incrementErrorCount();
                    }
                });
            })
        );

        // Process CompCircleScore caches similarly.
        viewCountryMap.keySet().forEach(vid -> {
            try {
                logger.info("Refreshing CompCircleScore for viewId {}.", vid);
                List<ViewInfo> rawData = da.getComplyCirclePerScoreAll(vid, "Comp", viewNameMap.get(vid), dateStr);
                logger.info("Retrieved {} detailed records for CompCircleScore for viewId {}.", rawData.size(), vid);
                
                Map<String, Map<Integer, List<ViewInfo>>> partitioned = rawData.stream()
                        .collect(Collectors.groupingBy(ViewInfo::getCountry,
                                Collectors.groupingBy(ViewInfo::getSupViewID)));
                
                partitioned.forEach((country, subMap) -> {
                    subMap.forEach((subViewId, list) -> {
                        String key = getCacheKey("CompCircleScore", "Comp", vid, country, dateStr)
                                     + "_sv_" + subViewId;
                        cacheProvider.put(key, list);
                        logger.info("Cached {} records for CompCircleScore for viewId {} for country {} and subViewID {}.", list.size(), vid, country, subViewId);
                    });
                });
                
                List<ViewInfo> aggBySubView = CacheDataProcessor.aggregateBySubView(rawData);
                aggBySubView.forEach(vi -> {
                    String key = getCacheKey("CompCircleScore", "Comp", vid, "all", dateStr)
                                 + "_sv_" + vi.getSupViewID();
                    cacheProvider.put(key, vi);
                    logger.info("Cached aggregated CompCircleScore sub-view record for viewId {} for subViewID {}.", vid, vi.getSupViewID());
                });
                
                List<ViewInfo> aggByCountry = CacheDataProcessor.aggregateByCountry(rawData);
                aggByCountry.forEach(vi -> {
                    String key = getCacheKey("CompCircleScore", "Comp", vid, vi.getCountry(), dateStr)
                                 + "_ctry";
                    cacheProvider.put(key, vi);
                    logger.info("Cached aggregated CompCircleScore country record for viewId {} for country {}.", vid, vi.getCountry());
                });
                
                List<ViewInfo> overallAgg = CacheDataProcessor.aggregateOverall(rawData);
                overallAgg.forEach(vi -> {
                    String key = getCacheKey("CompCircleScore", "Comp", vid, "all", dateStr)
                                 + "_overall_" + vi.getType();
                    cacheProvider.put(key, vi);
                    logger.info("Cached overall aggregated CompCircleScore record for viewId {} for type {}.", vid, vi.getType());
                });
            } catch (Exception e) {
                logger.error("Error refreshing CompCircleScore for viewId {}: {}", vid, e.getMessage());
                incrementErrorCount();
            }
        });
        
        logger.info("Dynamic cache refresh complete. Current cache size: {}", cacheProvider.size());
    }

    public void preloadCacheBackground(final int viewId, final int subViewId,
                                         final String country, final String viewText) {
        final String dateStr = sdf.format(date);
        executorService.submit(() -> {
            errorCount = 0;
            cacheEnabled = true;
            logger.info("Asynchronous cache preloading started.");
            refreshAllCacheData(dateStr);
            logger.info("Asynchronous cache preloading completed.");
        });
    }

    public void startAutoRefresh(final int viewId, final int subViewId, final String country, final String viewText) {
        if (scheduledExecutor == null || scheduledExecutor.isShutdown()) {
            scheduledExecutor = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();
        }
        int interval = cacheConfig.getAutoRefreshInterval();
        scheduledExecutor.scheduleAtFixedRate(() -> {
            String dateStr = sdf.format(date);
            logger.info("Automatic periodic cache refresh triggered at {}.", dateStr);
            refreshAllCacheData(dateStr);
        }, interval, interval, java.util.concurrent.TimeUnit.MINUTES);
    }

    public void stopAutoRefresh() {
        if (scheduledExecutor != null && !scheduledExecutor.isShutdown()) {
            scheduledExecutor.shutdown();
            logger.info("Automatic cache auto-refresh stopped.");
        }
    }

    public void shutdown() {
        executorService.shutdown();
        if (scheduledExecutor != null) {
            scheduledExecutor.shutdown();
        }
        cacheConfig.shutdown();
        logger.info("CacheService shutdown.");
    }

    public void startupFlow(final int viewId, final int subViewId, final String country, final String viewText) {
        preloadCacheBackground(viewId, subViewId, country, viewText);
        startAutoRefresh(viewId, subViewId, country, viewText);
        logger.info("CacheService startup flow completed.");
    }
    
    public void incrementErrorCount() {
        errorCount++;
        logger.error("An error occurred. Current error count: {}", errorCount);
        if (errorCount > cacheConfig.getErrorLimit()) {
            cacheEnabled = false; // Disable cache updates if too many errors occur.
            logger.error("Error limit exceeded. Cache updates are now disabled.");
        }
    }
}
