package com.app.dev.cmon.controllers;

import java.io.IOException;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.PostConstruct;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.ViewScoped;
import javax.faces.context.ExternalContext;
import javax.faces.context.FacesContext;
import javax.faces.event.AjaxBehaviorEvent;
import javax.servlet.http.HttpServletResponse;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.CreationHelper;
import org.apache.poi.ss.usermodel.FillPatternType;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import com.app.dev.cmon.components.AllRadarData;
import com.app.dev.cmon.components.AssetInfo;
import com.app.dev.cmon.components.ComplianceInfo;
import com.app.dev.cmon.components.Countres;
import com.app.dev.cmon.components.CountryCardComponent;
import com.app.dev.cmon.components.CountryLeftCardData;
import com.app.dev.cmon.components.HeaderView;
import com.app.dev.cmon.components.RadarDashValidation;
import com.app.dev.cmon.components.RadarHistorical;
import com.app.dev.cmon.components.RadarLeftCard;
import com.app.dev.cmon.components.Score;
import com.app.dev.cmon.components.ServiceSyncMain;
import com.app.dev.cmon.components.TotalAssetsHistory;
import com.app.dev.cmon.components.ViewInfo;
import com.app.dev.cmon.components.Views;
import com.app.dev.cmon.utilites.Commons;
import com.app.dev.cmon.utilites.RadarThresholds;
import com.arabbank.dev.utility.Pair;
import com.arabbank.dev.utility.Triple;
import com.arabbank.devf.cmon.controllers.portal.CmonManagedBean;

@ManagedBean(name = "mbMain")
@ViewScoped
public class MB_Main extends CmonManagedBean {

    // ===============================
    // Fields (mostly unchanged)
    // ===============================
    private CountryCardComponent countriesCard;
    private String curCountry = "ALL";
    private DataAccess da = new DataAccess();
    private String country = "";
    private List<String> upperMonthLabels = new ArrayList<>();
    private int viewId;
    private int subViewId = -1;
    private List<AssetInfo> assetList;
    private List<ComplianceInfo> complianceList;
    public Map<String, List<AssetInfo>> assetMap;
    public Map<String, List<AssetInfo>> excludeMap;
    public Map<String, List<ComplianceInfo>> complianceExcludeMap;
    public Map<String, List<ComplianceInfo>> complianceMap;
    private List<Views> viewList;
    private List<Views> symantecList = new ArrayList<>();
    private String viewText;
    private String subViewText = "All";
    private boolean isManual;
    private String COMPLIANCE_PATH_REDIRECT = "radar/inc/details-compliance.xhtml";
    private String COVERAGE_PATH_REDIRECT = "radar/inc/details-coverage.xhtml";
    private int selectedThresold;
    private LocalDate manualAssetScanDate;
    private LocalDate scanDate;
    private HashMap<String, List<RadarLeftCard>> radarLeftCardMap;
    private Views selectedView;
    private List<AssetInfo> assetTopRows;
    private HashMap<String, List<RadarLeftCard>> wsusLeftCardMap = new HashMap<>();
    private List<Pair<String, Long>> excludeList;
    private LocalDate now;
    private Date nowCycle;
    private List<AssetInfo> nowCycle1;
    private List<AssetInfo> excludeCovList;
    private List<ComplianceInfo> excludeCompList;
    private List<ViewInfo> veiwDataComp;
    private List<ViewInfo> veiwDataAll;
    private List<ViewInfo> veiwDataCov;
    private List<ViewInfo> veiwDataCompOneMonth;
    private List<ViewInfo> veiwDataCovOneMonth;
    private List<ViewInfo> veiwDataCompTwoMonth;
    private List<ViewInfo> veiwDataCovTwoMonth;
    private List<ViewInfo> veiwDataCompDate2;
    private List<ViewInfo> circleCompPerWeek;
    private List<ViewInfo> circleCovPerWeek;
    private List<ViewInfo> circleExiCompDetails;
    private List<ViewInfo> circleNewCompDetails;
    private List<AssetInfo> covDataList;
    private List<ComplianceInfo> compDataList;
    public Map<String, List<ViewInfo>> leftCardDataMap = new HashMap<>();
    public Map<String, List<ViewInfo>> wsusleftCardDataMap = new HashMap<>();
    public List<ViewInfo> leftCardList = new ArrayList<>();
    public List<AssetInfo> timeList = new ArrayList<>();
    public List<ViewInfo> headeData;
    public List<HeaderView> covHeaderData1;
    public List<HeaderView> covHeaderData2;
    public List<HeaderView> compHeaderData1;
    public List<HeaderView> compHeaderData2;
    public static HashMap<String, ViewInfo> headerMap = new HashMap<>();
    public static HashMap<String, Integer> covHeaderList1 = new HashMap<>();
    public static HashMap<String, Integer> covHeaderList2 = new HashMap<>();
    public static HashMap<String, Integer> compHeaderList1 = new HashMap<>();
    public static HashMap<String, Integer> compHeaderList2 = new HashMap<>();
    public HashMap<String, List<ViewInfo>> circleData = new HashMap<>();
    public List<AssetInfo> listPerWeek = new ArrayList<>();
    private Date date1 = new Date();
    private Date date2 = new Date();
    private List<CountryLeftCardData> countryAssetList;
    private List<ViewInfo> exeludedCov;
    private List<ViewInfo> exeludedComp;
    private String contriName;
    private String circleDetail = "";
    private Date dateComp;
    private Integer checkIsNew2;
    private Integer checkValue2;
    private String checkCountry;
    private Date dateComp2;
    List<ViewInfo> compUpperAndLo;
    List<ViewInfo> covUpperAndLo;
    public List<Score> scoreList;
    public Map<String, Pair<Integer, Double>> scoreMap = new HashMap<>();
    private int viewSymantecName;
    private Map<String, AllRadarData> allRadarData = new HashMap<>();
    List<AllRadarData> radarInfo = new ArrayList<>();
    Long itNewCov = 0L;
    Long itNewComp = 0L;
    Long itExistComp = 0L;
    Long itExistCov = 0L;
    Long RiskNewCov = 0L;
    Long RiskNewComp = 0L;
    Long RiskExistComp = 0L;
    Long RiskExistCov = 0L;
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    String formattedDate;
    private String cycleStatus;
    RadarController radar = ((RadarController) getManagedBeanByName("radarController"));
    RadarDataSource radarDataSource = ((RadarDataSource) getManagedBeanByName("RadarDataSource"));
    public List<AllRadarData> allRadar = new ArrayList<>();
    private AllRadarData filter;
    private List<String> countresAccess = new ArrayList<>();
    public HashMap<String, Double> countryValueMap = new HashMap<>();
    private List<ViewInfo> listOfTodayData;
    Triple<Double, Integer, Integer> tripleOneMonth = new Triple<>();
    Triple<Double, Integer, Integer> tripleTwoMonth = new Triple<>();
    Pair<Integer, Integer> pairCur;
    Pair<Integer, Integer> pairOneMonth;
    Pair<Integer, Integer> pairTwoMonth;
    private Map<String, Pair<Integer, Integer>> oneMonthMap = new HashMap<>();
    private Map<String, Pair<Integer, Integer>> twoMonthMap = new HashMap<>();
    List<AssetInfo> coverageAll;
    Commons commons = new Commons();
    List<RadarDashValidation> radarValidation = new ArrayList<>();
    public Map<String, List<AssetInfo>> exeludedCovMap = new HashMap<>();
    public Map<String, List<ComplianceInfo>> exeludedCompMap = new HashMap<>();
    public List<AssetInfo> excludedCovList;
    public List<ComplianceInfo> excludedCompList;
    List<String> colorTypes = Arrays.asList("Orange-Exist", "Orange-New", "Red-Exist", "Red-New");
    // ... other fields as necessary

    // ===============================
    // Initialization
    // ===============================
    @PostConstruct
    public void init() {
        // Retrieve validations and set basic date
        radarValidation = da.getRadarDashValidation();
        date1 = checkDateValidations(radarValidation);

        // Set up radar and view info
        radar.setLists();
        selectedView = radar.getSelectedView();
        country = radar.getCountry();
        curCountry = radar.getCurCountry();
        viewId = radar.getViewId();
        viewText = radar.getViewText();
        subViewId = radar.getSubViewId();

        // Load only lightweight data here; heavy data will be loaded lazily
        getDate(); // Assume this is lightweight (e.g., sets dateComp fields)
        logger.debug("MB_Main initialization complete; heavy data will be loaded on demand.");
    }

    // ===============================
    // Lazy Getters and Deferred Data Loading
    // ===============================
    public List<ViewInfo> getLeftCardData() {
        if (leftCardDataMap == null || leftCardDataMap.isEmpty()) {
            getLeftCardInfo();  // load left card mapping on demand
        }
        return leftCardDataMap.get(curCountry);
    }

    public List<ViewInfo> getListOfTodayData() {
        if (listOfTodayData == null) {
            String formatted = sdf.format(radar.getDate1()).trim();
            listOfTodayData = da.getHistoryData(radar.getUsername(), formatted);
        }
        return listOfTodayData;
    }

    public Pair<Integer, Integer> getTotalAssetAndTotalCoverd(int month) {
        ensureAssetMappingIsProcessed();
        String key = (country.toUpperCase().isEmpty() ? "ALL" : country) + subViewId;
        Pair<Integer, Integer> pair = (month == 1) ? oneMonthMap.get(key) : twoMonthMap.get(key);
        return (pair == null) ? new Pair<>() : pair;
    }

    private void ensureAssetMappingIsProcessed() {
        if (oneMonthMap == null || twoMonthMap == null || oneMonthMap.isEmpty() || twoMonthMap.isEmpty()) {
            processAndMapData();
        }
    }

    private void processAndMapData() {
        // Retrieve coverage data for one and two months and process into maps
        List<AssetInfo> listOne = da.getAllCoverage(viewId, -1, "", sdf.format(getPreviousMonth(1)));
        List<AssetInfo> listTwo = da.getAllCoverage(viewId, -1, "", sdf.format(getPreviousMonth(2)));
        oneMonthMap = processAssetList(listOne);
        twoMonthMap = processAssetList(listTwo);
    }

private Map<String, Pair<Integer, Integer>> processAssetList(List<AssetInfo> assetList) {
    // Group by individual LocationCode + SubViewId
    Map<String, Pair<Integer, Integer>> resultMap = assetList.stream()
        .collect(Collectors.groupingBy(
            asset -> asset.getLocationCode() + asset.getSubViewId(),
            Collectors.collectingAndThen(
                Collectors.toList(),
                assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
            )
        ));

    // Group by "ALL" for each SubViewId: treating all locations together per subview
    Map<String, Pair<Integer, Integer>> allGroupMapBySubViewId = assetList.stream()
        .collect(Collectors.groupingBy(
            asset -> "ALL" + asset.getSubViewId(),
            Collectors.collectingAndThen(
                Collectors.toList(),
                assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
            )
        ));

    // Group by all locations, but with SubViewId = -1 (i.e. a grouping by location code only)
    Map<String, Pair<Integer, Integer>> allLocationsMap = assetList.stream()
        .collect(Collectors.groupingBy(
            asset -> asset.getLocationCode() + "-1",
            Collectors.collectingAndThen(
                Collectors.toList(),
                assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
            )
        ));

    // Calculate overall total across all assets
    Pair<Integer, Integer> totalPair = assetList.stream()
        .collect(Collectors.collectingAndThen(
            Collectors.toList(),
            assets -> new Pair<>(assets.stream().mapToInt(AssetInfo::getIsCoveredByControl).sum(), assets.size())
        ));

    // Merge the additional groupings into the main result map
    resultMap.putAll(allGroupMapBySubViewId);
    resultMap.putAll(allLocationsMap);
    resultMap.put("ALL-1", totalPair);

    return resultMap;
}


    public LocalDate getScanDate() {
        Date date = da.getBulkScanDate(viewId, subViewId, country.equals("ALL") ? "" : country, 0);
        scanDate = convertDateToLocalDate(date);
        return scanDate;
    }

    // Lazy getter for header data
    public List<ViewInfo> getHeadeData() {
        if (headeData == null) {
            headeData = da.getHeaderData();
            filterHeaderData();
        }
        return headeData;
    }

    // ===============================
    // Helper Methods (some unchanged)
    // ===============================
    public void getLeftCardInfo() {
        RadarHistorical radarHist = new RadarHistorical();
        radarHist.setCompVal1(0);
        radarHist.setCompVal2(0);
        radarHist.setCovVal1(0);
        radarHist.setCovVal2(0);

        leftCardDataMap = new HashMap<>();
        List<String> countries = commons.getCountries();
        logger.debug("Start filtering left Card Data:");

        for (String c : countries) {
            List<ViewInfo> filteredList = getListOfTodayData().stream()
                .filter(item -> !item.getControlName().contains("Symantec -") && item.getCountry().equalsIgnoreCase(c))
                .peek(item -> item.setRadarHistorical(radarHist))
                .collect(Collectors.toList());
            leftCardDataMap.put(c, filteredList);
        }
        logger.debug("End filtering left Card Data:");
    }

    private LocalDate convertDateToLocalDate(Date date) {
        if (date == null) {
            return LocalDate.now();
        }
        return Instant.ofEpochMilli(date.getTime()).atZone(ZoneId.systemDefault()).toLocalDate();
    }

    public Date getPreviousDate(Date date) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.DAY_OF_MONTH, -1);
        return calendar.getTime();
    }

    public Date getPreviousMonth(int month) {
        LocalDate today = LocalDate.now();
        LocalDate resultDate = today.withDayOfMonth(1);
        switch (month) {
            case 1:
                resultDate = resultDate.minusMonths(1);
                break;
            case 2:
                resultDate = resultDate.minusMonths(2);
                break;
            case 3:
                resultDate = resultDate.minusMonths(3);
                break;
            default:
                throw new IllegalArgumentException("Invalid month value: " + month);
        }
        return Date.from(resultDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
    }

    // Example: filterHeaderData remains unchanged
    public void filterHeaderData() {
        for (ViewInfo item : headeData) {
            item.setRadarHistorical(getRadarHistoryLeftCard(item.getId(), item.getControlName(), item.getCountry()));
            headerMap.put(item.getId() + "-" + item.getSupViewID() + "-" + item.getCountry(), item);
        }
    }

    public RadarHistorical getRadarHistoryLeftCard(int id, String name, String country) {
        RadarHistorical radarHist = new RadarHistorical();
        // The original logic for setting radar history; unchanged
        radarHist.setCovVal1(0);
        radarHist.setCovVal2(0);
        radarHist.setCompVal1(0);
        radarHist.setCompVal2(0);
        return radarHist;
    }

    // Additional methods such as changeCountry, setViewIds, isSymantec, exportToExcel, etc.
    // remain largely unchanged. You can integrate lazy-loading into them where appropriate.
    // ... unchanged methods ...

    @Override
    public void reset() {
        veiwDataComp = null;
        veiwDataCov = null;
        veiwDataCompOneMonth = null;
        veiwDataCovOneMonth = null;
        veiwDataCompTwoMonth = null;
        veiwDataCovTwoMonth = null;
        circleCompPerWeek = null;
        circleCovPerWeek = null;
        circleExiCompDetails = null;
        circleNewCompDetails = null;
        exeludedCov = null;
        exeludedComp = null;
        checkIsNew2 = null;
        checkValue2 = null;
        checkCountry = null;
        scoreList = null;
        pairCur = null;
        pairOneMonth = null;
        pairTwoMonth = null;
    }

    // ... remaining methods from the original MB_Main go here, refactored if needed for lazy loading ...

}



