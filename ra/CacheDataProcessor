package com.app.dev.cmon.cache;

import com.app.dev.cmon.components.ViewInfo;
import java.util.*;
import java.util.stream.Collectors;

public class CacheDataProcessor {

    // Expected type orders for the two methods.
    private static final List<String> PER_WEEK_TYPES = Arrays.asList(">", "W1", "W2", "W3", "W4");
    private static final List<String> CIRCLE_TYPES = Arrays.asList("first", "second");

    /**
     * Aggregates a list of detailed ViewInfo records for per-week caching.
     * The aggregation groups by the type field, sums up numeric fields,
     * and sets country to "all" and subViewID to -1.
     * If no record exists for an expected type, a default record is created.
     */
    public static List<ViewInfo> aggregatePerWeekData(List<ViewInfo> rawData) {
        Map<String, ViewInfo> aggregated = new HashMap<>();
        for (ViewInfo vi : rawData) {
            String type = vi.getType();
            ViewInfo agg = aggregated.get(type);
            if (agg == null) {
                agg = createDefaultViewInfo(type);
                aggregated.put(type, agg);
            }
            agg.setGreenExist(agg.getGreenExist() + safe(vi.getGreenExist()));
            agg.setGreenNew(agg.getGreenNew() + safe(vi.getGreenNew()));
            agg.setOrangeExist(agg.getOrangeExist() + safe(vi.getOrangeExist()));
            agg.setOrangeNew(agg.getOrangeNew() + safe(vi.getOrangeNew()));
            agg.setRedExist(agg.getRedExist() + safe(vi.getRedExist()));
            agg.setRedNew(agg.getRedNew() + safe(vi.getRedNew()));
        }
        // Ensure that each expected type is present.
        for (String type : PER_WEEK_TYPES) {
            if (!aggregated.containsKey(type)) {
                aggregated.put(type, createDefaultViewInfo(type));
            }
        }
        // Return sorted according to the predefined order.
        return PER_WEEK_TYPES.stream()
                .map(aggregated::get)
                .collect(Collectors.toList());
    }

    /**
     * Aggregates a list of detailed ViewInfo records for circle per score caching.
     * Groups by type, sums up the numeric fields, and sets country to "all" and subViewID to -1.
     * If no record exists for an expected type, a default record is created.
     */
    public static List<ViewInfo> aggregateCircleData(List<ViewInfo> rawData) {
        Map<String, ViewInfo> aggregated = new HashMap<>();
        for (ViewInfo vi : rawData) {
            String type = vi.getType();
            ViewInfo agg = aggregated.get(type);
            if (agg == null) {
                agg = createDefaultViewInfo(type);
                aggregated.put(type, agg);
            }
            agg.setGreenExist(agg.getGreenExist() + safe(vi.getGreenExist()));
            agg.setGreenNew(agg.getGreenNew() + safe(vi.getGreenNew()));
            agg.setOrangeExist(agg.getOrangeExist() + safe(vi.getOrangeExist()));
            agg.setOrangeNew(agg.getOrangeNew() + safe(vi.getOrangeNew()));
            // For circle per score, red fields may not be relevant.
            agg.setRedExist(agg.getRedExist() + safe(vi.getRedExist()));
            agg.setRedNew(agg.getRedNew() + safe(vi.getRedNew()));
        }
        // Ensure defaults for expected circle types.
        for (String type : CIRCLE_TYPES) {
            if (!aggregated.containsKey(type)) {
                aggregated.put(type, createDefaultViewInfo(type));
            }
        }
        // Return sorted according to the predefined order.
        return CIRCLE_TYPES.stream()
                .map(aggregated::get)
                .collect(Collectors.toList());
    }

    private static ViewInfo createDefaultViewInfo(String type) {
        ViewInfo vi = new ViewInfo();
        vi.setType(type);
        vi.setCountry("all");
        vi.setSupViewID(-1);
        vi.setGreenExist(0L);
        vi.setGreenNew(0L);
        vi.setOrangeExist(0L);
        vi.setOrangeNew(0L);
        vi.setRedExist(0L);
        vi.setRedNew(0L);
        return vi;
    }

    private static Long safe(Long value) {
        return value == null ? 0L : value;
    }
}
